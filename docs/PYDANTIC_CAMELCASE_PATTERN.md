# Pydantic CamelCase Pattern for Frontend Compatibility

**Version**: 1.0  
**Date**: October 2025  
**Status**: Standard Pattern

## Overview

This document explains the standard pattern for making Pydantic models generate camelCase JSON schemas that are compatible with the frontend's JavaScript conventions.

## The Problem

Django/DRF's automatic camelCase conversion **only applies to model field names during data serialization**, not to JSON schema property names generated by Pydantic's `model_json_schema()`.

### What Gets Converted Automatically

```python
class MyModel(BaseModel):
    menu_items: List[str]
```

**Django serialization** (when sending/receiving data):
- Backend: `{"menu_items": [...]}`
- Frontend receives: `{"menuItems": [...]}`  ✅ Converted

### What Doesn't Get Converted

```python
schema = MyModel.model_json_schema()
# Returns: {"properties": {"menu_items": {...}}}
```

**JSON schema generation**:
- Backend: `{"properties": {"menu_items": {...}}}`
- Frontend receives: `{"properties": {"menu_items": {...}}}`  ❌ NOT converted

This is just a Python dictionary, not a model being serialized, so DRF doesn't touch it.

## The Solution

Use Pydantic's built-in `alias_generator` with `to_camel`:

```python
from pydantic import BaseModel, Field, ConfigDict
from pydantic.alias_generators import to_camel

class MyModel(BaseModel):
    model_config = ConfigDict(
        alias_generator=to_camel,      # snake_case → camelCase in JSON schema
        populate_by_name=True,          # Accept both snake_case and camelCase input
    )
    
    menu_items: List[str] = Field(...)
    page_id: str = Field(...)
```

Now the JSON schema will have:
```json
{
    "properties": {
        "menuItems": {...},
        "pageId": {...}
    }
}
```

## When to Use This Pattern

### ✅ Always Use For:

1. **Widget configuration models**
   ```python
   class NavigationConfig(BaseModel):
       model_config = ConfigDict(alias_generator=to_camel, populate_by_name=True)
   ```

2. **Nested config models** (for ConditionalGroupField)
   ```python
   class PageSectionConfig(BaseModel):
       model_config = ConfigDict(alias_generator=to_camel, populate_by_name=True)
   ```

3. **Any model whose schema is sent to the frontend**
   ```python
   class FormFieldConfig(BaseModel):
       model_config = ConfigDict(alias_generator=to_camel, populate_by_name=True)
   ```

### ❌ Don't Use For:

1. **Django ORM models** (use Django's built-in serialization)
2. **Backend-only models** (internal processing, no frontend interaction)
3. **API request/response models** (DRF handles the conversion)

## Complete Example

```python
"""
Example widget with proper camelCase schema generation.
"""

from typing import Type, Optional, List, Literal
from pydantic import BaseModel, Field, ConfigDict
from pydantic.alias_generators import to_camel

from webpages.widget_registry import BaseWidget, register_widget_type


class MenuItem(BaseModel):
    """Individual menu item"""
    
    model_config = ConfigDict(
        alias_generator=to_camel,
        populate_by_name=True,
    )
    
    label: str = Field(..., description="Menu label")
    url: str = Field(..., description="Menu URL")
    is_active: bool = Field(True, description="Active status")
    target_blank: bool = Field(False, description="Open in new tab")


class InternalLinkConfig(BaseModel):
    """Configuration for internal links"""
    
    model_config = ConfigDict(
        alias_generator=to_camel,
        populate_by_name=True,
    )
    
    page_id: str = Field(..., description="Internal page ID")
    show_icon: bool = Field(False, description="Show navigation icon")


class ExternalLinkConfig(BaseModel):
    """Configuration for external links"""
    
    model_config = ConfigDict(
        alias_generator=to_camel,
        populate_by_name=True,
    )
    
    external_url: str = Field(..., description="External URL")
    open_in_new_tab: bool = Field(True, description="Open in new tab")


class MenuConfig(BaseModel):
    """Configuration for menu widget"""
    
    model_config = ConfigDict(
        alias_generator=to_camel,
        populate_by_name=True,
    )
    
    menu_items: List[MenuItem] = Field(
        default_factory=list,
        description="Menu items",
        json_schema_extra={
            "component": "ItemsListField",
        }
    )
    
    link_type: Literal["internal", "external", "none"] = Field(
        "internal",
        description="Type of link",
        json_schema_extra={
            "component": "ConditionalGroupField",
            "groups": {
                "internal": {
                    "label": "Internal",
                    "configModel": "InternalLinkConfig"  # Note: camelCase
                },
                "external": {
                    "label": "External", 
                    "configModel": "ExternalLinkConfig"  # Note: camelCase
                },
                "none": {
                    "label": "None"
                }
            }
        }
    )


@register_widget_type
class MenuWidget(BaseWidget):
    """Menu widget"""
    
    name = "Menu"
    description = "Configurable menu widget"
    template_name = "widgets/menu.html"
    
    @property
    def configuration_model(self) -> Type[BaseModel]:
        return MenuConfig
```

## What the Frontend Receives

With the pattern above, the frontend receives:

```json
{
    "properties": {
        "menuItems": {
            "type": "array",
            "items": {
                "type": "object",
                "properties": {
                    "label": {"type": "string"},
                    "url": {"type": "string"},
                    "isActive": {"type": "boolean"},
                    "targetBlank": {"type": "boolean"}
                }
            }
        },
        "linkType": {
            "type": "string",
            "enum": ["internal", "external", "none"],
            "component": "ConditionalGroupField",
            "groups": {
                "internal": {
                    "label": "Internal",
                    "configModel": "InternalLinkConfig"
                },
                "external": {
                    "label": "External",
                    "configModel": "ExternalLinkConfig"
                },
                "none": {
                    "label": "None"
                }
            }
        }
    }
}
```

All property names are in camelCase, matching JavaScript conventions!

## Important Notes

### `populate_by_name=True`

Always include `populate_by_name=True` so the model accepts both:
- `menu_items` (from backend code)
- `menuItems` (from frontend/JSON)

This allows seamless bidirectional communication.

### Literal Values Stay snake_case

Enum values in Literals are **NOT** converted:

```python
link_type: Literal["page_sections", "page_submenu"]  # Values stay as-is
```

The frontend will work with `"page_sections"`, not `"pageSections"`. This is intentional - these are semantic identifiers, not UI strings.

### json_schema_extra Keys

Use camelCase in `json_schema_extra` dictionary keys if they're used by the frontend:

```python
json_schema_extra={
    "component": "ConditionalGroupField",
    "groups": {
        "internal": {
            "configModel": "InternalLinkConfig"  # camelCase
        }
    }
}
```

## Benefits

1. **Consistency**: Frontend code uses natural JavaScript conventions
2. **No Manual Conversion**: Automatic schema generation handles it
3. **Type Safety**: Pydantic validation works the same
4. **Bidirectional**: Works for both input and output
5. **Standard**: Built-in Pydantic feature, not a custom hack

## Migration Guide

For existing widgets without this pattern:

1. Add imports:
   ```python
   from pydantic import ConfigDict
   from pydantic.alias_generators import to_camel
   ```

2. Add `model_config` to each BaseModel:
   ```python
   class MyConfig(BaseModel):
       model_config = ConfigDict(
           alias_generator=to_camel,
           populate_by_name=True,
       )
   ```

3. No other changes needed! The field names stay `snake_case` in Python.

4. Frontend will start receiving camelCase schemas automatically.

## Testing

To verify the pattern is working:

1. **Check generated schema**:
   ```python
   schema = MyModel.model_json_schema()
   print(schema['properties'].keys())  # Should show camelCase names
   ```

2. **Test API response**:
   ```bash
   curl http://localhost:8000/api/v1/webpages/widget-types/MyWidget/schema/
   # Look for camelCase property names in response
   ```

3. **Frontend console**:
   ```javascript
   console.log(fieldSchema)
   // Should show { menuItems: {...}, pageId: {...} }
   ```

## Related Documentation

- [ConditionalGroupField Guide](./CONDITIONAL_GROUP_FIELD_GUIDE.md)
- [Pydantic Widget Controls Guide](./PYDANTIC_WIDGET_CONTROLS_GUIDE.md)
- [Widget System Documentation](./WIDGET_SYSTEM_DOCUMENTATION_INDEX.md)
- [Pydantic Alias Generator Docs](https://docs.pydantic.dev/latest/concepts/alias/)

