import React, { useState, useEffect, useRef, useMemo, useCallback } from 'react'
import { useParams, useNavigate, Link, Navigate, useLocation } from 'react-router-dom'
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query'
import {
    ArrowLeft, Layout, FileText, Settings, Calendar, Users, History,
    Eye
} from 'lucide-react'
import { objectInstancesApi, objectTypesApi, objectVersionsApi } from '../api/objectStorage'
import { useUnifiedData } from '../contexts/unified-data/context/UnifiedDataContext'
import { OperationTypes } from '../contexts/unified-data/types/operations'
import { useGlobalNotifications } from '../contexts/GlobalNotificationContext'
import StatusBar from '../components/StatusBar'

// Import individual tab components
import ObjectContentView from '../components/objectEdit/ObjectContentView'
import ObjectSettingsView from '../components/objectEdit/ObjectSettingsView'
import ObjectPublishingView from '../components/objectEdit/ObjectPublishingView'
import ObjectSubObjectsView from '../components/objectEdit/ObjectSubObjectsView'
import ObjectVersionsView from '../components/objectEdit/ObjectVersionsView'

const ObjectInstanceEditPage = () => {
    const { instanceId, objectTypeId, tab = 'content' } = useParams()
    const navigate = useNavigate()
    const location = useLocation()
    const { addNotification } = useGlobalNotifications()
    const { useExternalChanges, publishUpdate, saveCurrentVersion } = useUnifiedData()
    const queryClient = useQueryClient()

    // Save state management - sync with UDC's object dirty state
    const [hasUnsavedChanges, setHasUnsavedChanges] = useState(false)

    // Version management state
    const [currentVersion, setCurrentVersion] = useState(null)
    const [availableVersions, setAvailableVersions] = useState([])

    // Essential fields modal state
    const [showEssentialFieldsModal, setShowEssentialFieldsModal] = useState(false)

    // UDC initialization error state
    const [udcInitError, setUdcInitError] = useState(null)

    // Refs for tab components
    const contentTabRef = useRef(null)

    const componentId = useMemo(() => `object-instance-editor-${instanceId}`, [instanceId])

    // Subscribe to UDC's dirty state (like PageEditor does)
    // IMPORTANT: Use useCallback to keep subscription stable
    const handleStateChange = useCallback((state) => {
        setHasUnsavedChanges(state.metadata.isDirty);
    }, []);
    
    useExternalChanges(componentId, handleStateChange);

    // Create object mutation (for new objects before editing)
    const createNewObjectMutation = useMutation({
        mutationFn: async (essentialFields) => {
            const parentId = parentIdFromUrl || null

            const objectData = {
                object_type_id: objectType.id,
                title: essentialFields.title,
                // slug is auto-generated by backend from title
                status: 'draft',
                parent: parentId,
                data: {},
                widgets: {}
            }

            const newObject = await objectInstancesApi.create(objectData)
            return newObject
        },
        onSuccess: (newObject) => {
            setShowEssentialFieldsModal(false)
            addNotification('Object created successfully', 'success')
            queryClient.invalidateQueries(['objectInstances'])
            // Navigate to edit page with real ID
            navigate(`/objects/${newObject.data.id}/edit/content`)
        },
        onError: (error) => {
            console.error('Failed to create object:', error)
            addNotification('Failed to create object', 'error')
        }
    })

    const handleCreateNewObject = useCallback((essentialFields) => {
        createNewObjectMutation.mutate(essentialFields)
    }, [createNewObjectMutation])

    // Save mutation (only for existing objects)
    const saveMutation = useMutation({
        mutationFn: (saveData) => {
            if (saveData.createNew) {
                // Create new version
                return objectInstancesApi.createVersion(instanceId, saveData)
            } else {
                // Update current version
                return objectInstancesApi.update(instanceId, saveData)
            }
        },
        onSuccess: (response, variables) => {
            queryClient.invalidateQueries(['objectInstances'])
            queryClient.invalidateQueries(['objectInstance'])

            const message = variables.createNew
                ? 'New version created successfully'
                : 'Object updated successfully'

            addNotification(message, 'success')
            setHasUnsavedChanges(false)
        },
        onError: (error) => {
            console.error('Failed to save object:', error)
            addNotification('Failed to save object', 'error')
        }
    })

    // Extract parent ID from URL search params for new sub-objects
    const urlParams = new URLSearchParams(location.search)
    const parentIdFromUrl = urlParams.get('parent')

    const isNewInstance = !instanceId && objectTypeId
    const isEditingInstance = !!instanceId

    // Redirect if neither creating nor editing
    if (!isNewInstance && !isEditingInstance) {
        return <Navigate to="/objects" replace />
    }

    // Fetch object instance if editing
    const { data: instanceResponse, isLoading: instanceLoading } = useQuery({
        queryKey: ['objectInstance', instanceId],
        queryFn: () => objectInstancesApi.get(instanceId),
        enabled: !!instanceId
    })

    // Get object type ID from instance or params
    const actualObjectTypeId = instanceResponse?.data?.objectType?.id || objectTypeId

    // Fetch object type details
    const { data: objectTypeResponse, isLoading: typeLoading } = useQuery({
        queryKey: ['objectType', actualObjectTypeId],
        queryFn: () => objectTypesApi.get(actualObjectTypeId),
        enabled: !!actualObjectTypeId
    })

    // Load versions for existing instances
    const { data: versionsResponse, isLoading: versionsLoading } = useQuery({
        queryKey: ['objectInstance', instanceId, 'versions'],
        queryFn: () => objectInstancesApi.getVersions(instanceId),
        enabled: !!instanceId && !isNewInstance
    })

    const objectType = objectTypeResponse?.data
    const instance = instanceResponse?.data

    // Show modal for new instances
    useEffect(() => {
        if (isNewInstance && !instance && objectType) {
            setShowEssentialFieldsModal(true)
        }
    }, [isNewInstance, instance, objectType])

    // Update available versions when data loads
    useEffect(() => {
        if (versionsResponse?.data) {
            setAvailableVersions(versionsResponse.data)
            if (!currentVersion && instance) {
                // Find the version that matches the instance's current version number
                const current = versionsResponse.data.find(v => v.versionNumber === instance.version)
                    || versionsResponse.data[0] // Fallback to first (latest) version
                setCurrentVersion(current)
            }
        }
    }, [versionsResponse, instance, instanceLoading, versionsLoading])

    // Initialize UDC objects and versions once data is loaded
    useEffect(() => {
        if (!instanceId || !instance || !versionsResponse?.data) return

        try {
            // Clear any previous error state
            setUdcInitError(null)

            // Determine current version id and version ids list
            const allVersions = Array.isArray(versionsResponse.data) ? versionsResponse.data : []
            const currentVersionEntry = allVersions.find(v => v.versionNumber === instance.version) || allVersions[0]
            const currentVersionId = currentVersionEntry ? String(currentVersionEntry.id) : undefined
            const versionIds = allVersions.map(v => String(v.id))

            publishUpdate(componentId, OperationTypes.INIT_OBJECT, {
                id: String(instance.id),
                data: {
                    ...instance,
                    id: String(instance.id),
                    type: instance?.objectType?.name || instance?.objectType?.id || 'unknown',
                    status: instance?.status || 'draft',
                    metadata: instance?.metadata || {},
                    created_at: instance?.createdAt || new Date().toISOString(),
                    updated_at: instance?.updatedAt || new Date().toISOString(),
                    parentId: instance?.parent?.id || instance?.parent || null,
                    currentVersionId: currentVersionId,
                    availableVersions: versionIds
                }
            })
        } catch (e) {
            console.error('UDC init (objects) failed', e)
            setUdcInitError(e)
            addNotification(
                'Failed to initialize editor. Some features may not work correctly.',
                'error'
            )
        }
    }, [instanceId, instance, versionsResponse, publishUpdate, componentId, addNotification])

    // Switch to a different version
    const switchToVersion = async (versionId) => {
        if (!versionId || versionId === instance?.id) return

        try {
            const response = await objectVersionsApi.get(versionId)
            const versionData = response.data

            // Update current version
            const version = availableVersions.find(v => v.id === versionId)
            setCurrentVersion(version)

            // Reconstruct instance object with version data
            const reconstructedInstance = {
                ...instance, // Keep original instance structure (id, objectType, etc.)
                data: versionData.data, // Use version's data
                widgets: versionData.widgets, // Use version's widgets
                version: versionData.versionNumber, // Update version number
                updatedAt: versionData.createdAt, // Use version's creation time
                // Explicitly preserve objectType for UI components
                objectType: instance.objectType
            }

            // Update instance data with reconstructed object
            queryClient.setQueryData(['objectInstance', instanceId], { data: reconstructedInstance })

            addNotification(`Switched to version ${version?.versionNumber || 'Unknown'}`, 'info')
        } catch (error) {
            console.error('Failed to switch version:', error)
            addNotification('Failed to switch version', 'error')
        }
    }

    // Generate sub-objects tab label with allowed child types
    const getSubObjectsLabel = () => {
        const allowedChildTypes = objectType?.allowedChildTypes || []
        if (allowedChildTypes.length === 1) {
            return allowedChildTypes[0].label
        } else if (allowedChildTypes.length <= 3) {
            const typeNames = allowedChildTypes.map(t => t.label).join(', ')
            return typeNames
        } else {
            return `${allowedChildTypes.length} types`
        }
    }

    // Tab definitions with routing
    const tabs = [
        { id: 'content', label: 'Content', icon: Layout },
        // Only show sub-objects tab if there are allowed child types
        ...((objectType?.allowedChildTypes || []).length > 0 ? [{ id: 'subobjects', label: getSubObjectsLabel(), icon: Users }] : []),
        { id: 'settings', label: 'Settings', icon: Settings },
        { id: 'publishing', label: 'Publishing', icon: Calendar },
        ...(isEditingInstance ? [{ id: 'versions', label: 'Versions', icon: History }] : [])
    ]

    // Validate tab parameter
    const validTabs = tabs.map(t => t.id)
    if (!validTabs.includes(tab)) {
        const defaultTab = 'content'
        const redirectPath = isNewInstance
            ? `/objects/new/${objectTypeId}/${defaultTab}`
            : `/objects/${instanceId}/edit/${defaultTab}`
        return <Navigate to={redirectPath} replace />
    }

    const [isSaving, setIsSaving] = useState(false)
    const handleSave = useCallback(async () => {
        setIsSaving(true);
        try {
            await saveCurrentVersion(); // This dispatches SET_OBJECT_DIRTY(false) internally
            addNotification(
                'Current version saved',
                'success'
            );
        } catch (error) {
            console.error('Save failed:', error);
            addNotification(
                `Save failed: ${error?.message || 'Unknown error'}`,
                'error'
            );
        } finally {
            setIsSaving(false);
        }
    }, [saveCurrentVersion, addNotification]);

    // const handleSaveNew = useCallback(async () => {
    //     setIsSaving(true);
    //     try {
    //         await handleActualSave({ description: 'New version created', option: 'new' });
    //     } catch (error) {
    //         console.error('Save New failed:', error);
    //     } finally {
    //         setIsSaving(false);
    //     }
    // }, [handleActualSave]);


    const handleBack = () => {
        // If this object has a parent (either from URL param or instance data), 
        // navigate back to parent's sub-objects view
        const actualParentId = parentIdFromUrl || instance?.parent?.id || instance?.parent
        if (actualParentId) {
            navigate(`/objects/${actualParentId}/edit/subobjects`)
        } else {
            // If no parent, go to the list view filtered by this object's type
            const objectTypeName = objectType?.name
            if (objectTypeName) {
                navigate(`/objects/${objectTypeName}`)
            } else {
                navigate('/objects')
            }
        }
    }

    const getTabPath = (tabId) => {
        return isNewInstance
            ? `/objects/new/${objectTypeId}/${tabId}`
            : `/objects/${instanceId}/edit/${tabId}`
    }

    // Render current tab content
    const renderTabContent = () => {
        const commonProps = {
            objectType,
            instance,
            parentId: parentIdFromUrl || instance?.parent?.id || instance?.parent,
            isNewInstance,
            onUnsavedChanges: setHasUnsavedChanges,
            onSave: () => {
                // This is now handled by the footer buttons
                // Individual tabs can still trigger saves if needed
            },
            onCancel: handleBack,
            context: { contextType: 'object' }
        }

        switch (tab) {
            case 'content':
                return <ObjectContentView ref={contentTabRef} {...commonProps} />
            case 'settings':
                return <ObjectSettingsView {...commonProps} />
            case 'publishing':
                return <ObjectPublishingView {...commonProps} />
            case 'subobjects':
                return <ObjectSubObjectsView {...commonProps} />
            case 'versions':
                return <ObjectVersionsView {...commonProps} />
            default:
                return <div>Tab not found</div>
        }
    }

    const isLoading = instanceLoading || typeLoading

    if (isLoading) {
        return (
            <div className="min-h-screen bg-gray-50 flex items-center justify-center">
                <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600"></div>
            </div>
        )
    }

    if (!objectType) {
        return (
            <div className="min-h-screen bg-gray-50 flex items-center justify-center">
                <div className="text-center">
                    <h2 className="text-xl font-semibold text-gray-900 mb-2">Object Type Not Found</h2>
                    <p className="text-gray-600 mb-4">The specified object type could not be found.</p>
                    <button
                        onClick={handleBack}
                        className="bg-blue-600 text-white px-4 py-2 rounded-md hover:bg-blue-700"
                    >
                        Back to Objects
                    </button>
                </div>
            </div>
        )
    }

    return (
        <div className="h-screen bg-gray-50 flex flex-col">
            {/* Header - Fixed - Styled like PageEditor */}
            <div className="flex-shrink-0 bg-white border-b border-gray-200 shadow-sm">
                <div className="px-4 py-3">
                    <div className="flex items-center justify-between">
                        {/* Left section - Back button and object info */}
                        <div className="flex items-center space-x-4">
                            <button
                                onClick={handleBack}
                                className="flex items-center px-3 py-2 text-gray-600 hover:text-gray-900 hover:bg-gray-100 rounded-lg transition-colors"
                            >
                                <ArrowLeft className="w-4 h-4 mr-2" />
                                Back to Objects
                            </button>

                            <div className="h-6 w-px bg-gray-300"></div>

                            <div>
                                <h1 className="text-lg font-semibold text-gray-900 truncate flex items-center">
                                    {objectType?.iconImage ? (
                                        <img
                                            src={objectType.iconImage}
                                            alt={objectType.label}
                                            className="w-5 h-5 object-cover rounded mr-2"
                                        />
                                    ) : (
                                        <Layout className="h-5 w-5 mr-2" />
                                    )}
                                    {isNewInstance ? `New ${objectType?.label}` : instance?.title || 'Untitled'}
                                </h1>
                                <p className="text-sm text-gray-500">
                                    {isNewInstance
                                        ? `Create a new ${objectType?.label?.toLowerCase()}`
                                        : `Edit ${objectType?.label?.toLowerCase()}`
                                    }
                                </p>
                            </div>
                        </div>

                        {/* Center section - Tab navigation */}
                        <div className="flex items-center space-x-3">
                            <div className="hidden lg:flex items-center space-x-1">
                                {tabs.map((tabDef) => {
                                    const Icon = tabDef.icon
                                    const isActive = tab === tabDef.id

                                    return (
                                        <Link
                                            key={tabDef.id}
                                            to={getTabPath(tabDef.id)}
                                            className={`flex items-center px-4 py-2 rounded-lg transition-colors ${isActive
                                                ? 'bg-blue-100 text-blue-700'
                                                : 'text-gray-600 hover:text-gray-900 hover:bg-gray-100'
                                                }`}
                                        >
                                            <Icon className="w-4 h-4 mr-2" />
                                            {tabDef.label}
                                        </Link>
                                    )
                                })}
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            {/* Content Area - Scrollable */}
            <div className="flex-1 min-h-0">
                {/* Error banner for UDC initialization failures */}
                {udcInitError && (
                    <div className="bg-yellow-50 border-l-4 border-yellow-400 p-4 mx-4 mt-4">
                        <div className="flex">
                            <div className="flex-shrink-0">
                                <svg className="h-5 w-5 text-yellow-400" viewBox="0 0 20 20" fill="currentColor">
                                    <path fillRule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clipRule="evenodd" />
                                </svg>
                            </div>
                            <div className="ml-3 flex-1">
                                <p className="text-sm text-yellow-700">
                                    <strong className="font-medium">Editor initialization warning:</strong> Some features may not work correctly. You can continue editing, but saving may be affected.
                                </p>
                                <button
                                    onClick={() => {
                                        setUdcInitError(null)
                                        queryClient.invalidateQueries(['objectInstance', instanceId])
                                        queryClient.invalidateQueries(['objectInstance', instanceId, 'versions'])
                                    }}
                                    className="mt-2 text-sm font-medium text-yellow-700 hover:text-yellow-600 underline"
                                >
                                    Retry initialization
                                </button>
                            </div>
                        </div>
                    </div>
                )}
                {renderTabContent()}
            </div>

            {/* Status bar with notifications and save buttons */}
            <StatusBar
                isDirty={hasUnsavedChanges}
                currentVersion={currentVersion}
                availableVersions={availableVersions}
                onVersionChange={switchToVersion}
                onSaveClick={() => handleSave('update_current')}
                onSaveNewClick={() => handleSave('create_new')}
                isSaving={saveMutation.isPending}
                isNewPage={isNewInstance}
                customStatusContent={
                    <div className="text-sm text-gray-600">
                        {isNewInstance ? 'Creating' : 'Editing'} {objectType?.label} - {tabs.find(t => t.id === tab)?.label}
                    </div>
                }
            />

            {/* Essential Fields Modal for New Objects */}
            {showEssentialFieldsModal && (
                <ObjectEssentialFieldsModal
                    objectType={objectType}
                    onSave={handleCreateNewObject}
                    onCancel={() => {
                        setShowEssentialFieldsModal(false)
                        navigate('/objects')
                    }}
                    isLoading={createNewObjectMutation.isPending}
                />
            )}
        </div>
    )
}

// Essential Fields Modal Component
const ObjectEssentialFieldsModal = ({ objectType, onSave, onCancel, isLoading = false }) => {
    const [title, setTitle] = useState('')

    const handleSubmit = (e) => {
        e.preventDefault()
        if (!title.trim()) {
            return
        }
        onSave({ title })
    }

    return (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
            <div className="bg-white rounded-lg shadow-xl max-w-md w-full mx-4">
                <div className="p-6">
                    <h2 className="text-xl font-semibold mb-4">
                        Create New {objectType?.label || 'Object'}
                    </h2>
                    <p className="text-sm text-gray-600 mb-4">
                        Enter a title for your new {objectType?.label?.toLowerCase() || 'object'}.
                        A unique URL slug will be automatically generated.
                    </p>
                    <form onSubmit={handleSubmit} className="space-y-4">
                        <div>
                            <label className="block text-sm font-medium text-gray-700 mb-1">
                                Title *
                            </label>
                            <input
                                type="text"
                                value={title}
                                onChange={(e) => setTitle(e.target.value)}
                                className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
                                placeholder="Enter title"
                                required
                                autoFocus
                            />
                        </div>

                        <div className="flex justify-end gap-3 mt-6">
                            <button
                                type="button"
                                onClick={onCancel}
                                className="px-4 py-2 text-gray-700 border border-gray-300 rounded-md hover:bg-gray-50"
                                disabled={isLoading}
                            >
                                Cancel
                            </button>
                            <button
                                type="submit"
                                className="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 disabled:opacity-50"
                                disabled={isLoading || !title.trim()}
                            >
                                {isLoading ? 'Creating...' : 'Create'}
                            </button>
                        </div>
                    </form>
                </div>
            </div>
        </div>
    )
}

export default ObjectInstanceEditPage
