import { AppState, StateUpdate, StateSelector } from '../types/state';
import { Operation, ValidationResult, OperationTypes } from '../types/operations';
import { StateUpdateCallback, SubscriptionOptions } from '../types/subscriptions';
import { SubscriptionManager } from './SubscriptionManager';
import { defaultEqualityFn } from '../utils/equality';
import { OperationError, ValidationError, StateError, ErrorCodes, isRetryableError } from '../utils/errors';

interface PrioritizedOperation extends Operation {
    priority?: 'high' | 'normal' | 'low';
    timeoutId?: NodeJS.Timeout;
}

interface DebouncedOperation {
    operation: Operation;
    timeoutId: NodeJS.Timeout;
    resolve: (value: void | PromiseLike<void>) => void;
    reject: (reason?: any) => void;
}

/**
 * Core DataManager class responsible for state management, operations, and subscriptions
 */
export class DataManager {
    protected state: AppState;
    protected subscriptionManager: SubscriptionManager;
    protected operationQueue: PrioritizedOperation[] = [];
    protected isProcessing: boolean = false;
    protected selectorCache = new Map<string, any>();
    protected debouncedOperations = new Map<string, DebouncedOperation>();
    protected batchedNotifications = new Set<string>();
    protected batchTimeout: NodeJS.Timeout | null = null;

    constructor(initialState?: Partial<AppState>) {
        this.validateInitialState(initialState);

        // Initialize with default state structure (metadata is managed in UnifiedDataContext)
        this.state = {
            pages: {},
            widgets: {},
            layouts: {},
            versions: {},
            ...(initialState || {})
        };

        // Initialize subscription manager
        this.subscriptionManager = new SubscriptionManager();
    }

    /**
     * Validate initial state
     */
    protected validateInitialState(state?: Partial<AppState>): void {
        if (!state) return;

        try {
            // Validate widget-page relationships
            if (state.widgets && state.pages) {
                Object.values(state.widgets).forEach(widget => {
                    if (widget.pageId && !state.pages?.[widget.pageId]) {
                        throw new StateError(
                            ErrorCodes.INVALID_INITIAL_STATE,
                            `Widget ${widget.id} references non-existent page ${widget.pageId}`,
                            { widgetId: widget.id, pageId: widget.pageId }
                        );
                    }
                });
            }

            // Validate layout-slot relationships
            if (state.layouts) {
                Object.values(state.layouts).forEach(layout => {
                    const slotIds = new Set(layout.slots.map(s => s.id));
                    if (slotIds.size !== layout.slots.length) {
                        throw new StateError(
                            ErrorCodes.INVALID_INITIAL_STATE,
                            `Layout ${layout.id} contains duplicate slot IDs`,
                            { layoutId: layout.id }
                        );
                    }
                });
            }
        } catch (error) {
            if (error instanceof StateError) {
                throw error;
            }
            throw new StateError(
                ErrorCodes.INVALID_INITIAL_STATE,
                'Invalid initial state',
                { error }
            );
        }
    }

    /**
     * Get current state
     */
    public getState(): AppState {
        return this.state;
    }

    /**
     * Update state with new values
     */
    protected setState(update: StateUpdate): void {
        const prevState = this.state;
        
        // Handle function updates
        const newState = typeof update === 'function' 
            ? { ...prevState, ...update(prevState) }
            : { ...prevState, ...update };

        this.state = newState;
                
        // Clear selector cache
        this.selectorCache.clear();
        
        // Schedule notification
        this.scheduleStateNotification();
    }

    /**
     * Schedule batched state notifications
     */
    protected scheduleStateNotification(): void {
        if (this.batchTimeout) {
            clearTimeout(this.batchTimeout);
        }

        this.batchTimeout = setTimeout(() => {
            this.processBatchedNotifications();
        }, 0);
    }

    /**
     * Process batched notifications
     */
    protected processBatchedNotifications(): void {
        this.batchTimeout = null;
        this.subscriptionManager.notifyStateUpdate(this.state);
    }

    /**
     * Get memoized selector result
     */
    protected getMemoizedSelector<T>(selector: StateSelector<T>): T {
        const key = selector.toString();
        
        if (!this.selectorCache.has(key)) {
            this.selectorCache.set(key, selector(this.state));
        }
        
        return this.selectorCache.get(key);
    }

    /**
     * Validate an operation before processing
     */
    protected validateOperation(operation: Operation): ValidationResult {
        try {
            // Basic validation
            if (!operation.type || !Object.values(OperationTypes).includes(operation.type as any)) {
                throw new ValidationError(operation, 
                    `Invalid operation type: ${operation.type}`,
                    { type: operation.type }
                );
            }

            // Payload validation based on operation type
            switch (operation.type) {
                case OperationTypes.UPDATE_WIDGET_CONFIG:
                    if (!operationWithValidation.payload?.id || !operationWithValidation.payload?.config) {
                        throw new ValidationError(operation,
                            'Widget ID and config are required',
                            { payload: operationWithValidation.payload }
                        );
                    }
                    break;
                
                case OperationTypes.MOVE_WIDGET:
                    if (!operationWithValidation.payload?.id || !operationWithValidation.payload?.slot) {
                        throw new ValidationError(operation,
                            'Widget ID and slot are required',
                            { payload: operationWithValidation.payload }
                        );
                    }
                    break;
            }

            return { isValid: true };
        } catch (error) {
            if (error instanceof ValidationError) {
                return {
                    isValid: false,
                    errors: [{
                        field: error.code,
                        message: error.message,
                        code: error.code
                    }]
                };
            }
            
            return {
                isValid: false,
                errors: [{
                    field: 'unknown',
                    message: error instanceof Error ? error.message : 'Unknown error',
                    code: ErrorCodes.INVALID_OPERATION
                }]
            };
        }
    }

    /**
     * Process a single operation with rollback support
     */
    protected async processOperation(operation: Operation): Promise<void> {
        const previousState = { ...this.state };
        const updatedOperation: Operation = {
            ...operation,
            metadata: {
                ...operation.metadata,
                timestamp: Date.now()
            }
        };
        
        try {
            const validation = this.validateOperation(updatedOperation);
            if (!validation.isValid && validation.errors && validation.errors.length > 0) {
                throw new ValidationError(
                    updatedOperation,
                    `Invalid operation: ${validation.errors[0].message}`,
                    validation.errors
                );
            }

            // Add validation result to operation metadata
            const operationWithValidation: Operation = {
                ...updatedOperation,
                metadata: {
                    ...updatedOperation.metadata,
                    validation
                }
            };

            // Process based on operation type
            switch (operationWithValidation.type) {
                case OperationTypes.UPDATE_WIDGET_CONFIG: {
                    const { id, config } = operationWithValidation.payload;
                    this.setState(state => {
                        const existingWidget = state.widgets[id];
                        
                        if (!existingWidget) {
                            return state;
                        }

                        return {
                            widgets: {
                                ...state.widgets,
                                [id]: {
                                    ...existingWidget,
                                    config: {
                                        ...existingWidget.config,
                                        ...config
                                    },
                                    updated_at: new Date().toISOString()
                                }
                            }
                        };
                    });
                    break;
                }

                case OperationTypes.MOVE_WIDGET: {
                    const { id, slot, order } = operationWithValidation.payload;
                    this.setState(state => {
                        const widget = state.widgets[id];
                        if (!widget) {
                            return state;
                        }

                        return {
                            widgets: {
                                ...state.widgets,
                                [id]: {
                                    ...widget,
                                    slot,
                                    order,
                                    updated_at: new Date().toISOString()
                                }
                            }
                        };
                    });
                    break;
                }

                case OperationTypes.ADD_WIDGET: {
                    const { widgetId, widgetType, slotId, config, pageId } = operationWithValidation.payload;
                    this.setState(state => {
                        const newWidget = {
                            id: widgetId,
                            type: widgetType,
                            slot: slotId,
                            config: config || {},
                            order: 0,
                            pageId,
                            created_at: new Date().toISOString(),
                            updated_at: new Date().toISOString()
                        };

                        return {
                            widgets: {
                                ...state.widgets,
                                [newWidget.id]: newWidget
                            }
                        };
                    });
                    break;
                }

                case OperationTypes.REMOVE_WIDGET: {
                    const { id } = operationWithValidation.payload;
                    this.setState(state => {
                        const { [id]: removedWidget, ...remainingWidgets } = state.widgets;
                        return {
                            widgets: remainingWidgets
                        };
                    });
                    break;

                case OperationTypes.BATCH:
                    if (Array.isArray(operationWithValidation.payload)) {
                        for (const op of operationWithValidation.payload) {
                            await this.processOperation(op);
                        }
                    }
                    break;

                case OperationTypes.SET_DIRTY:
                    // No-op: isDirty is now handled in UnifiedDataContext
                    break;

                case OperationTypes.RESET_STATE:
                case OperationTypes.CLEAR_ERRORS:
                case OperationTypes.MARK_WIDGET_SAVED:
                    // No-op: These operations are now handled in UnifiedDataContext
                    break;

                case OperationTypes.LOAD_PAGE_DATA:
                    this.setState(state => {
                        console.log('📥 Loading page data into UnifiedDataContext:', operationWithValidation.payload);
                        
                        return {
                            pages: {
                                ...state.pages,
                                [operationWithValidation.payload.pageId]: operationWithValidation.payload.pageData
                            },
                            widgets: {
                                ...state.widgets,
                                ...operationWithValidation.payload.widgets
                            },
                            layouts: operationWithValidation.payload.layouts ? {
                                ...state.layouts,
                                ...operationWithValidation.payload.layouts
                            } : state.layouts,
                            versions: operationWithValidation.payload.versions ? {
                                ...state.versions,
                                ...operationWithValidation.payload.versions
                            } : state.versions,
                            // No metadata updates needed
                        };
                    });
                    break;

                case OperationTypes.LOAD_WIDGET_DATA:
                    this.setState(state => ({
                        widgets: {
                            ...state.widgets,
                            ...operationWithValidation.payload.widgets
                        }
                    }));
                    break;

                case OperationTypes.LOAD_LAYOUT_DATA:
                    this.setState(state => ({
                        layouts: {
                            ...state.layouts,
                            [operationWithValidation.payload.layoutId]: operationWithValidation.payload.layoutData
                        }
                    }));
                    break;

                case OperationTypes.SYNC_FROM_API:
                    this.setState(state => ({
                        ...state,
                        ...operationWithValidation.payload.stateUpdates
                    }));
                    break;

                // Page operations
                case OperationTypes.UPDATE_PAGE:
                    this.setState(state => {
                        const page = state.pages[operationWithValidation.payload.pageId];
                        if (!page) return state;

                        return {
                            pages: {
                                ...state.pages,
                                [operationWithValidation.payload.pageId]: {
                                    ...page,
                                    ...operationWithValidation.payload.updates,
                                    updated_at: new Date().toISOString()
                                }
                            }
                        };
                    });
                    break;

                case OperationTypes.UPDATE_PAGE_METADATA:
                    this.setState(state => {
                        const page = state.pages[operationWithValidation.payload.pageId || operationWithValidation.payload.id];
                        if (!page) return state;

                        return {
                            pages: {
                                ...state.pages,
                                [page.id]: {
                                    ...page,
                                    metadata: {
                                        ...page.metadata,
                                        ...operationWithValidation.payload.metadata
                                    },
                                    updated_at: new Date().toISOString()
                                }
                            }
                        };
                    });
                    break;

                case OperationTypes.CREATE_PAGE:
                    this.setState(state => {
                        const newPage = {
                            id: operationWithValidation.payload.pageId,
                            title: operationWithValidation.payload.title || 'New Page',
                            slug: operationWithValidation.payload.slug || 'new-page',
                            metadata: operationWithValidation.payload.metadata || {},
                            layout: operationWithValidation.payload.layout || 'single_column',
                            version: operationWithValidation.payload.versionId || '',
                            status: 'draft',
                            created_at: new Date().toISOString(),
                            updated_at: new Date().toISOString()
                        };

                        return {
                            pages: {
                                ...state.pages,
                                [newPage.id]: newPage
                            }
                        };
                    });
                    break;

                case OperationTypes.DELETE_PAGE:
                    this.setState(state => {
                        const { [operationWithValidation.payload.pageId]: deletedPage, ...remainingPages } = state.pages;
                        
                        // Also remove associated widgets and versions
                        const remainingWidgets = Object.fromEntries(
                            Object.entries(state.widgets).filter(([_, widget]) => 
                                widget.pageId !== operationWithValidation.payload.pageId
                            )
                        );
                        
                        const remainingVersions = Object.fromEntries(
                            Object.entries(state.versions).filter(([_, version]) => 
                                version.page_id !== operationWithValidation.payload.pageId
                            )
                        );

                        return {
                            pages: remainingPages,
                            widgets: remainingWidgets,
                            versions: remainingVersions,
                            // No metadata updates needed
                                isDirty: true
                            }
                        };
                    });
                    break;

                case OperationTypes.PUBLISH_PAGE:
                    this.setState(state => {
                        const page = state.pages[operationWithValidation.payload.pageId];
                        if (!page) return state;

                        return {
                            pages: {
                                ...state.pages,
                                [operationWithValidation.payload.pageId]: {
                                    ...page,
                                    status: 'published',
                                    updated_at: new Date().toISOString()
                                }
                            }
                        };
                    });
                    break;

                case OperationTypes.UNPUBLISH_PAGE:
                    this.setState(state => {
                        const page = state.pages[operationWithValidation.payload.pageId];
                        if (!page) return state;

                        return {
                            pages: {
                                ...state.pages,
                                [operationWithValidation.payload.pageId]: {
                                    ...page,
                                    status: 'draft',
                                    updated_at: new Date().toISOString()
                                }
                            }
                        };
                    });
                    break;

                case OperationTypes.SCHEDULE_PAGE:
                    this.setState(state => {
                        const page = state.pages[operationWithValidation.payload.pageId];
                        if (!page) return state;

                        return {
                            pages: {
                                ...state.pages,
                                [operationWithValidation.payload.pageId]: {
                                    ...page,
                                    status: 'scheduled',
                                    metadata: {
                                        ...page.metadata,
                                        scheduledPublishAt: operationWithValidation.payload.publishAt
                                    },
                                    updated_at: new Date().toISOString()
                                }
                            }
                        };
                    });
                    break;

                case OperationTypes.DUPLICATE_PAGE:
                    this.setState(state => {
                        const originalPage = state.pages[operationWithValidation.payload.pageId];
                        if (!originalPage) return state;

                        const newPageId = operationWithValidation.payload.newPageId || 
                                        `page-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
                        
                        const duplicatedPage = {
                            ...originalPage,
                            id: newPageId,
                            title: `${originalPage.title} (Copy)`,
                            slug: operationWithValidation.payload.newSlug || `${originalPage.slug}-copy`,
                            status: 'draft',
                            created_at: new Date().toISOString(),
                            updated_at: new Date().toISOString()
                        };

                        // Duplicate associated widgets
                        const duplicatedWidgets: Record<string, any> = {};
                        Object.values(state.widgets).forEach(widget => {
                            if (widget.pageId === operationWithValidation.payload.pageId) {
                                const newWidgetId = `widget-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
                                duplicatedWidgets[newWidgetId] = {
                                    ...widget,
                                    id: newWidgetId,
                                    pageId: newPageId,
                                    created_at: new Date().toISOString(),
                                    updated_at: new Date().toISOString()
                                };
                            }
                        });

                        return {
                            pages: {
                                ...state.pages,
                                [newPageId]: duplicatedPage
                            },
                            widgets: {
                                ...state.widgets,
                                ...duplicatedWidgets
                            }
                        };
                    });
                    break;

                // Layout operations
                case OperationTypes.CREATE_LAYOUT:
                    this.setState(state => {
                        const newLayout = {
                            id: operationWithValidation.payload.layoutId,
                            name: operationWithValidation.payload.name || 'New Layout',
                            slots: operationWithValidation.payload.slots || [],
                            theme: operationWithValidation.payload.theme,
                            metadata: operationWithValidation.payload.metadata || {},
                            created_at: new Date().toISOString(),
                            updated_at: new Date().toISOString()
                        };

                        return {
                            layouts: {
                                ...state.layouts,
                                [newLayout.id]: newLayout
                            }
                        };
                    });
                    break;

                case OperationTypes.UPDATE_LAYOUT:
                    this.setState(state => {
                        const layout = state.layouts[operationWithValidation.payload.layoutId];
                        if (!layout) return state;

                        return {
                            layouts: {
                                ...state.layouts,
                                [operationWithValidation.payload.layoutId]: {
                                    ...layout,
                                    ...operationWithValidation.payload.updates,
                                    updated_at: new Date().toISOString()
                                }
                            }
                        };
                    });
                    break;

                case OperationTypes.UPDATE_LAYOUT_THEME:
                    this.setState(state => {
                        const layout = state.layouts[operationWithValidation.payload.layoutId];
                        if (!layout) return state;

                        return {
                            layouts: {
                                ...state.layouts,
                                [operationWithValidation.payload.layoutId]: {
                                    ...layout,
                                    theme: operationWithValidation.payload.theme,
                                    updated_at: new Date().toISOString()
                                }
                            }
                        };
                    });
                    break;

                case OperationTypes.ADD_LAYOUT_SLOT:
                    this.setState(state => {
                        const layout = state.layouts[operationWithValidation.payload.layoutId];
                        if (!layout) return state;

                        const newSlot = {
                            id: operationWithValidation.payload.slot.id || `slot-${Date.now()}`,
                            name: operationWithValidation.payload.slot.name || 'New Slot',
                            allowedWidgets: operationWithValidation.payload.slot.allowedWidgets || [],
                            metadata: operationWithValidation.payload.slot.metadata || {}
                        };

                        return {
                            layouts: {
                                ...state.layouts,
                                [operationWithValidation.payload.layoutId]: {
                                    ...layout,
                                    slots: [...layout.slots, newSlot],
                                    updated_at: new Date().toISOString()
                                }
                            }
                        };
                    });
                    break;

                case OperationTypes.REMOVE_LAYOUT_SLOT:
                    this.setState(state => {
                        const layout = state.layouts[operationWithValidation.payload.layoutId];
                        if (!layout) return state;

                        return {
                            layouts: {
                                ...state.layouts,
                                [operationWithValidation.payload.layoutId]: {
                                    ...layout,
                                    slots: layout.slots.filter(slot => slot.id !== operationWithValidation.payload.slotId),
                                    updated_at: new Date().toISOString()
                                }
                            }
                        };
                    });
                    break;

                case OperationTypes.UPDATE_LAYOUT_SLOT:
                    this.setState(state => {
                        const layout = state.layouts[operationWithValidation.payload.layoutId];
                        if (!layout) return state;

                        return {
                            layouts: {
                                ...state.layouts,
                                [operationWithValidation.payload.layoutId]: {
                                    ...layout,
                                    slots: layout.slots.map(slot =>
                                        slot.id === operationWithValidation.payload.slotId
                                            ? { ...slot, ...operationWithValidation.payload.updates }
                                            : slot
                                    ),
                                    updated_at: new Date().toISOString()
                                }
                            }
                        };
                    });
                    break;

                case OperationTypes.REORDER_LAYOUT_SLOTS:
                    this.setState(state => {
                        const layout = state.layouts[operationWithValidation.payload.layoutId];
                        if (!layout) return state;

                        const reorderedSlots = operationWithValidation.payload.slotIds.map(slotId =>
                            layout.slots.find(slot => slot.id === slotId)
                        ).filter(Boolean);

                        return {
                            layouts: {
                                ...state.layouts,
                                [operationWithValidation.payload.layoutId]: {
                                    ...layout,
                                    slots: reorderedSlots,
                                    updated_at: new Date().toISOString()
                                }
                            }
                        };
                    });
                    break;

                case OperationTypes.DUPLICATE_LAYOUT:
                    this.setState(state => {
                        const originalLayout = state.layouts[operationWithValidation.payload.layoutId];
                        if (!originalLayout) return state;

                        const newLayoutId = operationWithValidation.payload.newLayoutId || 
                                          `layout-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;

                        const duplicatedLayout = {
                            ...originalLayout,
                            id: newLayoutId,
                            name: operationWithValidation.payload.newName || `${originalLayout.name} (Copy)`,
                            created_at: new Date().toISOString(),
                            updated_at: new Date().toISOString()
                        };

                        return {
                            layouts: {
                                ...state.layouts,
                                [newLayoutId]: duplicatedLayout
                            }
                        };
                    });
                    break;

                case OperationTypes.DELETE_LAYOUT:
                    this.setState(state => {
                        const { [operationWithValidation.payload.layoutId]: deletedLayout, ...remainingLayouts } = state.layouts;

                        return {
                            layouts: remainingLayouts,
                            // No metadata updates needed
                                isDirty: true
                            }
                        };
                    });
                    break;

                // Version operations
                case OperationTypes.CREATE_VERSION:
                    this.setState(state => {
                        const pageId = operationWithValidation.payload.pageId;
                        const page = state.pages[pageId];
                        if (!page) return state;

                        const newVersionId = operationWithValidation.payload.versionId || 
                                           `version-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;

                        // Get current page widgets for this version
                        const pageWidgets = Object.fromEntries(
                            Object.entries(state.widgets).filter(([_, widget]) => widget.pageId === pageId)
                        );

                        const newVersion = {
                            id: newVersionId,
                            page_id: pageId,
                            number: (Object.values(state.versions).filter(v => v.page_id === pageId).length + 1),
                            data: {
                                layout: page.layout,
                                widgets: pageWidgets,
                                metadata: page.metadata
                            },
                            created_at: new Date().toISOString(),
                            created_by: operationWithValidation.payload.createdBy || 'system',
                            status: 'draft'
                        };

                        return {
                            versions: {
                                ...state.versions,
                                [newVersionId]: newVersion
                            },
                            pages: {
                                ...state.pages,
                                [pageId]: {
                                    ...page,
                                    version: newVersionId,
                                    updated_at: new Date().toISOString()
                                }
                            }
                        };
                    });
                    break;

                case OperationTypes.PUBLISH_VERSION:
                    this.setState(state => {
                        const version = state.versions[operationWithValidation.payload.versionId];
                        if (!version) return state;

                        // Unpublish other versions of the same page
                        const updatedVersions = Object.fromEntries(
                            Object.entries(state.versions).map(([id, v]) => [
                                id,
                                v.page_id === version.page_id && v.id !== version.id
                                    ? { ...v, status: 'draft' as const }
                                    : v
                            ])
                        );

                        // Publish this version
                        updatedVersions[version.id] = {
                            ...version,
                            status: 'published' as const
                        };

                        return {
                            versions: updatedVersions,
                            // No metadata updates needed
                                isDirty: true
                            }
                        };
                    });
                    break;

                case OperationTypes.REVERT_VERSION:
                    this.setState(state => {
                        const version = state.versions[operationWithValidation.payload.versionId];
                        const pageId = operationWithValidation.payload.pageId;
                        if (!version || !pageId) return state;

                        // Update page to use this version's data
                        const page = state.pages[pageId];
                        if (!page) return state;

                        // Replace current widgets with version's widgets
                        const versionWidgets = version.data.widgets || {};
                        const otherWidgets = Object.fromEntries(
                            Object.entries(state.widgets).filter(([_, widget]) => widget.pageId !== pageId)
                        );

                        return {
                            pages: {
                                ...state.pages,
                                [pageId]: {
                                    ...page,
                                    layout: version.data.layout,
                                    metadata: version.data.metadata,
                                    version: version.id,
                                    updated_at: new Date().toISOString()
                                }
                            },
                            widgets: {
                                ...otherWidgets,
                                ...versionWidgets
                            }
                        };
                    });
                    break;

                case OperationTypes.DELETE_VERSION:
                    this.setState(state => {
                        const { [operationWithValidation.payload.versionId]: deletedVersion, ...remainingVersions } = state.versions;

                        return {
                            versions: remainingVersions,
                            // No metadata updates needed
                                isDirty: true
                            }
                        };
                    });
                    break;

                case OperationTypes.COMPARE_VERSIONS:
                    // This operation doesn't modify state, just returns comparison data
                    // The comparison logic would be handled in the hook
                    break;
            }

            // Notify operation subscribers
            this.subscriptionManager.notifyOperation(updatedOperation);
            
        } catch (error) {
            // Rollback on failure
            this.state = previousState;
            
            // Just throw the error, error state is handled in UnifiedDataContext
            throw error;
        }
    }

    /**
     * Process operation with retry logic
     */
    protected async executeOperation(
        operation: Operation,
        retries: number = 3,
        delay: number = 1000
    ): Promise<void> {
        try {
            await this.processOperation(operation);
        } catch (error) {
            if (retries > 0 && error instanceof Error && isRetryableError(error)) {
                await new Promise<void>(resolve => setTimeout(resolve, delay));
                await this.executeOperation(operation, retries - 1, delay * 2);
            } else {
                throw error;
            }
        }
    }

    /**
     * Process operation queue with priority handling
     */
    protected async processQueue(): Promise<void> {
        if (this.isProcessing || this.operationQueue.length === 0) return;

        this.isProcessing = true;
        
        try {
            // Sort by priority
            this.operationQueue.sort((a, b) => {
                const priorityMap: Record<string, number> = { high: 0, normal: 1, low: 2 };
                const aPriority = a.priority || 'normal';
                const bPriority = b.priority || 'normal';
                return priorityMap[aPriority] - priorityMap[bPriority];
            });

            while (this.operationQueue.length > 0) {
                const operation = this.operationQueue.shift();
                if (operation) {
                    await this.executeOperation(operation);
                }
            }
        } finally {
            this.isProcessing = false;
        }
    }

    /**
     * Dispatch an operation with optional debouncing
     */
    public async dispatch(
        operation: Operation,
        options: { 
            priority?: 'high' | 'normal' | 'low';
            debounce?: number;
        } = {}
    ): Promise<void> {
        const { priority = 'normal', debounce } = options;

        if (typeof debounce === 'number') {
            return this.debounceOperation(operation, debounce);
        }

        // Queue the operation with priority
        const queuedOperation: PrioritizedOperation = { ...operation, priority };
        this.operationQueue.push(queuedOperation);
        
        // Process queue
        await this.processQueue();
    }

    /**
     * Debounce an operation
     */
    protected debounceOperation(operation: Operation, delay: number): Promise<void> {
        const key = `${operation.type}_${operation.payload?.id || 'global'}`;
        
        // Clear existing debounced operation
        const existing = this.debouncedOperations.get(key);
        if (existing) {
            clearTimeout(existing.timeoutId);
            existing.reject(new Error('Operation superseded'));
            this.debouncedOperations.delete(key);
        }

        return new Promise<void>((resolve, reject) => {
            const timeoutId = setTimeout(async () => {
                try {
                    await this.processOperation(operation);
                    this.debouncedOperations.delete(key);
                    resolve();
                } catch (error) {
                    reject(error);
                }
            }, delay);

            const debouncedOperation: DebouncedOperation = {
                operation,
                timeoutId,
                resolve,
                reject
            };
            this.debouncedOperations.set(key, debouncedOperation);
        });
    }

    /**
     * Subscribe to state changes with memoization
     */
    public subscribe<T>(
        selector: StateSelector<T>,
        callback: StateUpdateCallback<T>,
        options: SubscriptionOptions = {}
    ): () => void {
        return this.subscriptionManager.subscribe(
            (state) => this.getMemoizedSelector(() => selector(state)),
            callback,
            {
                equalityFn: defaultEqualityFn,
                ...options
            }
        );
    }

    /**
     * Subscribe to operations
     */
    public subscribeToOperations(
        callback: (operation: Operation) => void,
        operationTypes?: string | string[]
    ): () => void {
        return this.subscriptionManager.subscribeToOperations(
            callback,
            operationTypes
        );
    }

    /**
     * Clear all subscriptions and caches
     */
    public clear(): void {
        this.subscriptionManager.clearAllSubscriptions();
        this.selectorCache.clear();
        this.debouncedOperations.forEach(({ timeoutId }) => clearTimeout(timeoutId));
        this.debouncedOperations.clear();
        if (this.batchTimeout) {
            clearTimeout(this.batchTimeout);
            this.batchTimeout = null;
        }
    }
}